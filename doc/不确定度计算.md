# 不确定度计算

## 数据结构
```
{
    "whole_name": "whole_name", //流程(整张大表)的名称
    "model_list": [
        "model1",
        "model2"
    ], //表中模块列表，相当于索引
    "model1": { //模块,这里写model1是为了方便理解,命名规范请看1.1 -3
        "model_name": "name", //模块名称
        "has_table": 1, //该模块是否拥有列表,"1"是，"-1"否
        "has_array": 1, //该模块是否拥有数组,"1"是,且代表有一张数据表，"-1"否
        "table": { //列表内容
            "cell_list": [
                {
                    "row": "row1",
                    "col": "col1",
                    "cell_name": "cell_name",
                    "cell_sn": "1"
                }
            ],
            "row1": { //行,在索引中指明了行列名称，能够快速定位单元格
                "col1": { //列,在索引中指明了行列名称，能够快速定位单元格
                    "sn": "1", //该单元格编码，唯一变量，用于指定唯一单元格
                    "name": "name", //该单元格名称(必填)
                    "source_type": "1", //单元格来源类型
                    "source": {
                        "source_name": "source_name", //单元格数据来源类型
                        "source_sn": "{model_key}#{cell_sn}", //来源格式，这里来源格式根据类型的不同，内容也不同
                        "sourcedate": {}, //该单元格来源数据（若来源类型需要则启用，否则为空）
                    },
                    "value": "", //该单元格当前显示的数据
                    "row": "1", //每个单元格都应该确定自己的行号
                    "col": "1", //每个单元格都应该确定自己的列号
                },
                "col2": {
                    //...
                }
            }
        },
        "array_list": [
            "array1",
            "array2"
        ],
        "array1": { //数组内容
            "array_col": 10, //数组列数，一般列不会变动
            "array_row": 10, //数组行数
            "col_list": [
                {
                    "row": "1",
                    "col": "A",
                    "name": "name",
                    "sn": "A1"
                },
                {
                    "row": "1",
                    "col": "B",
                    "name": "name",
                    "sn": "B1"
                },
                //...
            ],
            "1": { //数组第一行为表头
                "A": { //第一列
                    "sn": "1", //该单元格编码
                    "name": "name", //该单元格名称(必填)
                    "source_type": "1", //单元格来源类型
                    "source": {
                        "source_name": "source_name", //单元格数据来源类型
                        "source_sn": "{model_key}#{array}#{cell:A2:A30}#{own:A2:A30}|{model_key}#{array}#{cell:B31:B35}#{own:A31:A35}", //来源格式，这里来源格式根据类型的不同，内容也不同
                        "sourcedate": {}, //该单元格来源数据（若来源类型需要则启用，否则为空）
                    },
                    "row": "A", //每个单元格都应该确定自己的行号
                    "col": "1", //每个单元格都应该确定自己的列号
                },
                "B": { //第二列
                    "sn": "1", //该单元格编码
                    "name": "name", //该单元格名称(必填)
                    "source_type": "1", //单元格来源类型
                    "source": {
                        "source_name": "source_name", //单元格数据来源类型
                        "source_sn": "{model_key}#{array}#{cell:A2:A30}#{own:A2:A30}|{model_key}#{array}#{cell:B31:B35}#{own:A31:A35}", //来源格式，这里来源格式根据类型的不同，内容也不同
                        "sourcedate": {}, //该单元格来源数据（若来源类型需要则启用，否则为空）
                    }
                },
                //...
            },
            "2": { //第二行开始只有数组的值
                "A": {
                    "value": "", //该单元格需要显示的数据
                    "source_type": "1", //这段数据理论上是与表头同步的
                    "source": {
                        "source_name": "source_name", //单元格数据来源类型
                        "source_sn": "{model_key}#{array}#{cell:{row}}#{own:{row}}", //来源格式，这里来源格式根据类型的不同，内容也不同
                        "sourcedate": {}, //该单元格来源数据（若来源类型需要则启用，否则为空）
                    },
                    "row": "B", //每个单元格都应该确定自己的行号
                    "col": "1", //每个单元格都应该确定自己的列号
                },
                "B": {
                    "defaultvalue": "", //该单元格需要显示的数据
                    "source_type": "1", //这段数据理论上是与表头同步的
                    "source": {
                        "source_name": "source_name", //单元格数据来源类型
                        "source_sn": "{model_key}#{array}#{cell:{row}}#{own:{row}}", //来源格式，这里来源格式根据类型的不同，内容也不同
                        "sourcedate": {}, //该单元格来源数据（若来源类型需要则启用，否则为空）
                    },
                    "row": "B", //每个单元格都应该确定自己的行号
                    "col": "2", //每个单元格都应该确定自己的列号
                },
                //...
            },
            "array2":{
                //...
            }
        }
    }
}
```

#### 新增
1. 重写数据表类型，增加流程中的模块列表，单元格列表，以及数组列表，类似索引，能够快捷定位到需要的模块。数据源字符串类似如下：`{extra}#{model_key}#{cell_sn}`,考虑到单元格名的重复性以及不确定性这里使用模块SN来确定唯一模块，通过解析这一段字符串，能够快速定位到表中的单元格，完成数据的绑定。头部"{extra}"指明这是从普通模块里取数据，还是从不确定度模块里取数据。两种字符串如下: 
    - `{common}#{model_key}#{cell_sn}`
    - `{extra}#{model_key}#{table|array}#{data_key}`
2. 重写了数组中单元格的数据结构，增加了大量可自定义的特性:
    - 为表格中每一个单元格增加了独立的数据源，保证了表格中的每一个单元格都能够实现自定义。
    - 修改表格行列为Excel样式，如A1，A2。
    - 数组中数据源的说明:
        - 表头数据源: `{force#extra|common}#{model_key}#{array}#{cell:A2:A30}#{own:A2:A30}|{force}#{model_key}#{array}#{cell:B31:B35}#{own:A31:A35}`,通过 `{model_key}#{array}`能够定位到数组所在，同时确定对方表格引用数据的范围，以及在当前表格中数据拷贝的范围，需要注意: **两个数据范围的大小必须相同**，否则将会出现数据的丢失。使用了"|"符号分割了2个不同的数据源，能够实现多表同时引用。开头的`{force}`，用作判断是否强制覆盖指定单元格的数据源。
        - 单元格数据源: 单元格数据源理论上会跟着表头数据源走，但是表头数据源默认会覆盖单元格数据源类型为默认的那些单元格的数据源，若单元格数据源之前已经自定义过，在默认设置下，则无法被表头数据源覆盖，若设置了force属性，则单元格会被强制覆盖。
        - 单元格数据源字符串: `{model_key}#{array}#{cell:{row}}#{own:{row}}`，这是被表头数据源覆盖以后的数据源，记录着引用的是模块数组中哪一个单元格的数据，此数据源亦可单独设定，可以试任意一种类型的数据源，但是只有当数据源类型是默认的时候，才会被表头数据源覆盖，若要强制覆盖，参见上一条说明。
    - 增加不确定度模块:
        - 不确定度模块与普通模块绑定，每一个普通模块都有对应的不确定度模块。并且不确定度模块中有包含了模块中数据的索引，方便数据的引用。
        - 不确定度模块中，公式中引用数据源采用"{}"的形式，解析时，会将{}中的数据替换为相应的数据，然后计算。
        - 关于公式的计算，有以下方案: 
            - 在服务器端进行计算，似乎可以使用java的POI方案，达到完全兼容Excel公式的目的。
            - 在本地计算，使用逆波兰表达式解析公式，计算出最后的结果
        - 不确定度计算数据中包含"level"字段，该字段标明了这个数据是中间过程数据，还是最终数据，能够设置该字段的显示与隐藏。
3. 性能相关，为了保证数据的实时性，表格会动态加载，为了降低表格频繁加载所带来的性能的下降，考虑采用如下设计模式:（实验特性，不一定能实现）
    - 每一个单元格单独渲染，根据单元格ID来动态渲染表格，实现哪个单元格修改，就渲染哪个单元格，减少因修改表格而频繁对单元格进行渲染。
    - 采用索引，加快流程中对于单元格的搜索。
    - 公式计算放在服务器端，第一能够最大限度兼容Excel公式，第二能够减小客户端的压力，对低配机器友好。