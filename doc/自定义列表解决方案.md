###自定义列表解决方案

####理想数据格式
	{											//流程
	"model1":{ 								//模块,这里写model1是为了方便理解,命名规范请看1.1 -3
		"modelname":"name",					//模块名称
		"hastable":"1",						//该模块是否拥有列表,"1"是，"-1"否
		"hasarray":"1",						//该模块是否拥有数组,"1"是，"-1"否
		"table":{								//列表内容
			"row1":{							//行,这里写row1是为了方便理解,我认为用 "1" 更方便
				"col1":{						//列,这里写col1是为了方便理解,我认为用 "1" 更方便
					"sn":"1",					//该单元格编码
					"name":"name",			//该单元格名称(必填)
					"sourceid":"1",			//该单元格来源类型(必填，用于快速判断数据类型，用这个字段可以省去现在代码中关于类型判断的部分)
					"sourcename":"source",	//该单元格来源类型
					sourcesn: "",				//计算时解析使用的来源格式(便于快速定位数据来源)
					“defaultvalue”:"",		//该单元格需要显示的数据
					"sourcedate":{},			//该单元格来源数据(可能不需要)
					"row":"1",				//每个单元格都应该确定自己的行号
					"col":"1",				//每个单元格都应该确定自己的列号
					}
				}
			}
		"array":{							//数组内容
			"1":{							//数组第一行为表头
				"1":{						//第一列
					"sn":"1",					//该单元格编码
					"name":"name",			//该单元格名称(必填)
					"sourceid":"1",			//该单元格来源类型
					"sourcename":"source",	//该单元格来源类型
					"sourcesn": "",			//计算时解析使用的来源格式
					},
				"2":{						//第二列
					"sn":"1",					//该单元格编码
					"name":"name",			//该单元格名称(必填)
					"sourceid":"1",			//该单元格来源类型
					"sourcename":"source",	//该单元格来源类型
					"sourcesn": "",			//计算时解析使用的来源格式
					},
				}
			"2":{							//第二行开始只有数组的值
				"1":{			
					“defaultvalue”:"",		//该单元格需要显示的数据
					"sourcedate":{},			//该单元格来源数据(可能不需要)
					"row":"2",				//每个单元格都应该确定自己的行号
					"col":"1",				//每个单元格都应该确定自己的列号
					},
				"2":{			
					“defaultvalue”:"",		//该单元格需要显示的数据
					"sourcedate":{},			//该单元格来源数据(可能不需要)
					"row":"2",				//每个单元格都应该确定自己的行号
					"col":"2",				//每个单元格都应该确定自己的列号
					}	
				}
			}
		}
	}
	
####1.数据格式修改作用
#####1.1流程
1. 每个流程是一个原始记录表，需要以一个整体加载到自定义指令中进行处理，否则难以在各个模块之间进行数据交互。
2. 本系统需要用到自定义指令的原因在于：
	- 我们创建的模块均应该可以作为一个独立的个体展示和运算；
	- 同时，我们创建的流程仅需要进行n各模块的组合,然后手工绑定模块间的交互数据；
	- 由上两条得出:我们需要一个通用的处理方法
	- 无法使用传统表格模式的原因在于，模块本身是一个单元格数、类型、行、列、宽度不规则的表格,大部分模块都是不同的；
	- 有意思的是，流程也是如此，每个流程拥有不同数量、顺序的模块，并且他们之间的数据交互也有很大的随意性(相对于程序来说)
	- 综上：我们无法使用现有的某个控件完成将流程展示成表格这个过程，也不能通过一个固定页面完成它。他需要大量的判断和逻辑处理，这个必须交由html与js共同完成，并且该表格在本系统中在多个操作中均有展示，代码复用率高，为了减少重复代码和提高修改、优化效率，应该使用自定义指令。
3. 修改内容：参考文档开头数据格式
	- 这份数据应该来自从数据库中获取的流程数据data.json
	- 关于流程其他信息，例如名称、状态，请通过data.name,data.status获取
	- 流程这一级的k为"model1","model2","model3".....本流程有几个模块，就有几项**（强调:每个模块需要独立区分，任何情况下k与v必须唯一对应）**
	- "model1"命名规范:我认为只需要在流程表的数据库中增加一个字段snindex,初始为0；意义是记录模块在流程中的唯一建索引，在修改/新增时使用作为模块编码,使用时将其+1
	- 由于创建流程时，使用的是列表形式，要实现成json格式，需要提供两个转换函数：
			
			function flowArrayToObject(array){
				var object = {};
				return object;
			} ;
			function flowObjectToArray(object){
				var array = [];
				return array;
			}
	
	- 利用上面的方法，在创建/修改流程界面，使用的是数组:
		
			[
		 	{type:"model",sn:"1",modelid:"1",modelname:"name"},
			{type:"model",sn:"2",modelid:"3"},
			{type:"model",sn:"3",modelid:"4"}
			{type:"picture",sn:"4",pictureid:"1"},
			{type:"text",sn:"5"},
			]		
		
	- 在查看/保存入数据库时，使用的是对象:
			
			{
				"model_1_1":{
					modelname:"name"
					}
			}
4. 流程中具体要修改的部分，下列出清单及建议顺序：
	- 1.在后台新增一个字段snindex,用于帮助建立模块编码
	- 2.在操作流程新增/修改模块时，将snindex+1，并使用snindex加入/修改sn，
	- 3.创建两个方法flowArrayToObject，flowObjectToArray；如果能建在全局最好，可以复用代码，新增/修改流程都可以使用。
	- 4.保存流程前，使用flowArrayToObject方法，转换为json形式，传入数据库。
	- 5.如果上述步骤无误的情况下，此时页面列表应该已经显示不了了，原因是原本的数组型已经变成json型了。这时调用flowObjectToArray方法，可以恢复显示

5.  **注：在理解文档的情况下上述5步，除第一步每一步应该不需要新增太多代码，如果某一步骤修改超过20行以上，请截图联系我，可能是我考虑不周**

#####1.2模块
模块作为流程的基石,也是展示的基本单位，他需要较多的改动，为了契合流程获取数据,应将模块代码作如下改动：

1. 修改内容：参考文档开头数据格式.model1 的 值来源于 model表的json字段
2. 将modelname置入json，
3. 置入两个新字段hastable，hasarray,分别标记该模块包含的单元格数量与数组数量，当其为-1时认为无单元格或无数组
4. 置入两个新字段table,array,分别表示普通表格和数组
5. table,按行设置字典k值 1-n ; 相同行号的 单元格 按顺序设置列的k值 1-n ;

		例如：模块test1 ,3行，每行3，2，2列，无数组，对应的mode.json数据格式为：
		{
			modelname:"test1",
			hastable:"7",
			hasarray:"-1",
			table:{
				"1":{
					"1":{},
					"2":{},
					"3":{}
				},
				"2":{
					"1":{},
					"2":{}
				}
				"3":{
					"1":{},
					"2":{}
				}
			}	
		}
6. 每一个单元格在创建/修改模块时代表一条数据，所以与流程一样，模块中也需要建立modelArrayToObject，modelObjectToArray两个方法用于在存入数据库数据与页面列表展示数据之间进行切换。
7. 现需要的每行模块字典展示如下：

		"sn":"1",					//该单元格的唯一编码，创建方式与流程中模块的sn相同，用于唯一区分单元格
		"name":"name",			//该单元格名称(必填)
		"sourceid":"1",			//该单元格来源类型(必填，用于快速判断数据类型，用这个字段可以省去现在代码中关于类型判断的部分)
		"sourcename":"source",	//该单元格来源类型
		"sourcedate":{},			//该单元格来源数据(可能不需要)
		“defaultvalue”:"",		//该单元格需要显示的数据
		"row":"1",				//每个单元格都应该确定自己的行号
		"col":"1",				//每个单元格都应该确定自己的列号
		
	sourceid : 1 - 5 分别对应录入/日期/参数表/公式/数组/关联值(关联值仅能通过流程中的手动关联进行修改)  
	sourcename:具体的来源信息(显示)，与sourceid分别对应:录入 / 日期 / tab#col / a+b+c / 数组 / model(来自流程)#rowname  
	sourcesn : 具体的来源信息(计算)，与sourcename分别对应:input / date / table_id#col_index / a + b + c / array / modelsn(来自流程)#row#col 
	
		公式：
		sourceid:4
		sourcename：参数表1#列2 + 参数表3#列1 / 当前模块变量a(2行2列) + 1000
		sourcesn: 1#1 + 3#0 / -1#2#2
		
	defaultvalue：实际的显示值  
	sourcedate:针对数据来源为参数表/公式的单元格，在其获取数据后，存放其对应的整行数据，用作数据关联，使用场景：在每次计算前/修改后将该行数据按 {表:被选取选取数据} 存放在内存中，遇到同模块相同数据表的数值可以直接从中获取对应的关联数据   
	**注：sourcedate只在自定义指令中被赋值与使用 **
	
		sourcedate:[{},{}] //数组的原因是可能存在多条数据供其他单元格选择
		
		内存中数据：
		即定义一个全局变量 :
		DATAVALUE = {
			model_sn : {
				table_id:[{}],
				table_id:[{}],
				}
			}
		可以从中获取同一模块中同一参数表的值
		
	

8. 模块中具体要修改的部分，下列出清单及建议顺序：
	- 1.在后台新增一个字段snindex,用于帮助建立唯一编码
	- 2.在操作模块新增/修改单元格时，将snindex+1，并使用snindex加入/修改sn，
	- 3.创建两个方法modelArrayToObject，modelObjectToArray；如果能建在全局最好，可以复用代码，新增/修改模块都可以使用。
	- 4.保存模块前，使用modelArrayToObject方法，转换为json形式，传入数据库。
	- 5.如果上述步骤无误的情况下，此时页面列表应该已经显示不了了，原因是原本的数组型已经变成json型了。这时调用modelObjectToArray方法，可以恢复显示

9.  **注：模块修改内容比流程多，多在他需要更多的字段在确定自身属性，并且有model和array两个大类，数组值的**





		

		